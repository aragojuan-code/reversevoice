<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Laboratorio de Ecos Invertidos</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#171a2b; --ink:#e8ecff; --muted:#9aa7ffcc;
      --accent:#8be9fd; --good:#4ade80; --warn:#fbbf24; --bad:#fb7185;
      --border:#1f2342; --tile:#0f1330;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
      background:linear-gradient(180deg,#0b0e1a,#121629);color:var(--ink);
    }
    header{padding:18px 14px;text-align:center}
    h1{margin:0;font-size:clamp(22px,3.5vw,34px);letter-spacing:.2px}
    .subtitle{margin:6px 0 0;font-size:13px;color:var(--muted)}
    main{max-width:920px;margin:0 auto;padding:12px 14px 28px;display:grid;gap:14px}
    .card{
      background:var(--panel);border:1px solid var(--border);border-radius:16px;
      padding:12px 12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.25)
    }
    .section-title{margin:0 0 10px;font-size:16px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row > *{flex:1 1 auto}
    label{font-size:13px;color:var(--muted)}
    input[type=text]{
      width:100%;padding:11px 12px;border-radius:12px;background:var(--tile);
      border:1px solid #212757;color:var(--ink);outline:none;min-width:0
    }
    input[type=text]::placeholder{color:#9aa7ff99}
    button{
      appearance:none;border:0;border-radius:12px;padding:11px 12px;background:#23284d;
      color:var(--ink);font-weight:600;cursor:pointer;transition:.15s transform,.15s filter,.2s background;white-space:nowrap
    }
    button:hover{filter:brightness(1.08)}
    button:active{transform:translateY(1px)}
    .primary{background:linear-gradient(135deg,#3b82f6,#8b5cf6)}
    .good{background:linear-gradient(135deg,#22c55e,#16a34a)}
    .warn{background:linear-gradient(135deg,#f59e0b,#eab308)}
    .bad{background:linear-gradient(135deg,#ef4444,#f43f5e)}
    .ghost{background:transparent;border:1px solid #2a2f5d}
    .pill{
      display:inline-flex;align-items:center;gap:8px;padding:7px 10px;border-radius:999px;
      background:var(--tile);border:1px solid #26306b;font-size:12px;color:var(--muted)
    }
    .grid{display:grid;gap:10px}
    .cols-2{grid-template-columns:1fr 1fr}
    @media (max-width:800px){ .cols-2{grid-template-columns:1fr} }
    .center{display:flex;justify-content:center;align-items:center}
    .score{font-weight:800;font-size:clamp(22px,5vw,40px)}
    .score.good{color:var(--good)} .score.mid{color:var(--warn)} .score.bad{color:var(--bad)}
    .small{font-size:12px;color:#b6c1ffcc}
    .mute{opacity:.75}
    .hidden{display:none !important}
    canvas{
      width:100%;height:64px;
      background:#0b0f29;border-radius:10px;border:1px solid #212757
    }
    @media (min-width:900px){ canvas{height:72px} }

    /* Estado de GRABACI√ìN visible */
    .recording{
      background:linear-gradient(135deg,#b91c1c,#ef4444) !important;
      box-shadow:0 0 0 0 rgba(239,68,68,.75);
      animation:pulse 1.2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%{box-shadow:0 0 0 0 rgba(239,68,68,.55)}
      70%{box-shadow:0 0 0 12px rgba(239,68,68,0)}
      100%{box-shadow:0 0 0 0 rgba(239,68,68,0)}
    }
  </style>
</head>
<body>
  <header>
    <h1>Laboratorio de Ecos Invertidos</h1>
    <p class="subtitle">Graba ‚Üí escucha al rev√©s ‚Üí im√≠talo ‚Üí lo volvemos al derecho ‚Üí compara</p>
  </header>

  <main>
    <section class="card">
      <div class="grid">
        <div class="row">
          <label for="phrase">Frase gu√≠a (opcional):</label>
          <input id="phrase" type="text" placeholder="Escribe aqu√≠ la frase que vas a decir (opcional)">
        </div>
        <div class="row" style="align-items:center">
          <span class="pill">Micr√≥fono: <b id="permState">pendiente</b></span>
          <button id="btnPerms" class="ghost" style="flex:0 0 auto">Conceder permiso</button>
          <span class="small mute" style="flex:1 1 100%">Tip: usa <b>https</b> o <b>localhost</b> para que funcione el micro.</span>
        </div>
      </div>
    </section>

    <section class="card">
      <h3 class="section-title">1) Graba tu frase</h3>
      <div class="grid cols-2">
        <div>
          <div class="row">
            <button id="rec1" class="primary">‚è∫Ô∏è Grabar</button>
            <button id="stop1" class="bad" disabled>‚èπÔ∏è Detener</button>
            <button id="dl1" class="ghost" disabled>‚¨áÔ∏è Descargar</button>
          </div>
          <audio id="audio1" controls class="hidden"></audio>
          <canvas id="wave1"></canvas>
        </div>
        <div>
          <div class="row">
            <button id="playRev1" class="warn" disabled>üîÅ Escuchar al rev√©s</button>
          </div>
          <audio id="audio1rev" controls class="hidden"></audio>
          <canvas id="wave1rev"></canvas>
        </div>
      </div>
    </section>

    <section class="card">
      <h3 class="section-title">2) Im√≠talo al rev√©s</h3>
      <div class="grid cols-2">
        <div>
          <div class="row">
            <button id="rec2" class="primary" disabled>‚è∫Ô∏è Grabar intento</button>
            <button id="stop2" class="bad" disabled>‚èπÔ∏è Detener</button>
            <button id="dl2" class="ghost" disabled>‚¨áÔ∏è Descargar</button>
          </div>
          <audio id="audio2" controls class="hidden"></audio>
          <canvas id="wave2"></canvas>
        </div>
        <div>
          <div class="row">
            <button id="playFix2" class="good" disabled>‚Ü©Ô∏è Volver al derecho</button>
          </div>
          <audio id="audio2fix" controls class="hidden"></audio>
          <canvas id="wave2fix"></canvas>
        </div>
      </div>
    </section>

    <section class="card">
      <h3 class="section-title">3) Comparar</h3>
      <div class="grid cols-2">
        <div class="center">
          <div>
            <div class="score" id="score">‚Äî</div>
            <div class="small mute">0‚Äì100 (orientativo)</div>
          </div>
        </div>
        <div>
          <div class="row">
            <button id="btnCompare" class="ghost" disabled>üìè Calcular similitud</button>
            <button id="btnReset" class="ghost">‚ôªÔ∏è Reiniciar</button>
          </div>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  // --- Estado ---
  let mediaStream = null;
  let mediaRecorder1 = null, mediaRecorder2 = null;
  let chunks1 = [], chunks2 = [];
  let blob1 = null, blob2 = null;
  let ctx = null;

  // Buffers decodificados
  let buf1 = null, buf1Rev = null, buf2 = null, buf2Fix = null;

  // --- Elementos ---
  const $ = (id) => document.getElementById(id);
  const permState = $('permState'), btnPerms = $('btnPerms');

  const rec1 = $('rec1'), stop1 = $('stop1'), audio1 = $('audio1');
  const playRev1 = $('playRev1'), audio1rev = $('audio1rev');
  const wave1 = $('wave1'), wave1rev = $('wave1rev'), dl1 = $('dl1');

  const rec2 = $('rec2'), stop2 = $('stop2'), audio2 = $('audio2');
  const playFix2 = $('playFix2'), audio2fix = $('audio2fix');
  const wave2 = $('wave2'), wave2fix = $('wave2fix'), dl2 = $('dl2');

  const scoreEl = $('score'), btnCompare = $('btnCompare'), btnReset = $('btnReset');

  // --- Helpers audio ---
  const ensureCtx = () => (ctx ||= new (window.AudioContext || window.webkitAudioContext)());

  async function requestMic() {
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      permState.textContent = 'concedido';
      btnPerms.disabled = true;
    } catch (e) {
      permState.textContent = 'denegado';
      alert('No se pudo acceder al micr√≥fono. Abre el archivo en https/localhost y concede permisos.');
      throw e;
    }
  }

  function armRecorder(which) {
    const mr = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });
    const chunks = [];
    mr.ondataavailable = (e) => { if (e.data.size) chunks.push(e.data); };
    mr.onstop = async () => {
      const blob = new Blob(chunks, { type: 'audio/webm' });
      if (which === 1) { blob1 = blob; await handleRecordedBlob(blob1, 1); }
      else { blob2 = blob; await handleRecordedBlob(blob2, 2); }
    };
    return { mr, chunks };
  }

  async function handleRecordedBlob(blob, which) {
    const arrayBuf = await blob.arrayBuffer();
    const audioCtx = ensureCtx();
    const decoded = await audioCtx.decodeAudioData(arrayBuf.slice(0));

    if (which === 1) {
      buf1 = decoded;
      audio1.src = URL.createObjectURL(blob);
      audio1.classList.remove('hidden');
      drawWaveform(decoded, wave1);

      buf1Rev = reverseBuffer(decoded);
      const revBlob = await bufferToBlob(buf1Rev, audioCtx.sampleRate);
      audio1rev.src = URL.createObjectURL(revBlob);
      audio1rev.classList.remove('hidden');
      drawWaveform(buf1Rev, wave1rev);

      playRev1.disabled = false; dl1.disabled = false; rec2.disabled = false;
    } else {
      buf2 = decoded;
      audio2.src = URL.createObjectURL(blob);
      audio2.classList.remove('hidden');
      drawWaveform(decoded, wave2);

      buf2Fix = reverseBuffer(decoded);
      const fixBlob = await bufferToBlob(buf2Fix, ensureCtx().sampleRate);
      audio2fix.src = URL.createObjectURL(fixBlob);
      audio2fix.classList.remove('hidden');
      drawWaveform(buf2Fix, wave2fix);

      playFix2.disabled = false; dl2.disabled = false;
      btnCompare.disabled = !(buf1 && buf2Fix);
    }
  }

  function reverseBuffer(buffer) {
    const audioCtx = ensureCtx();
    const out = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
      const src = buffer.getChannelData(ch);
      const dst = out.getChannelData(ch);
      for (let i = 0, j = src.length - 1; i < src.length; i++, j--) dst[i] = src[j];
    }
    return out;
  }

  function drawWaveform(buffer, canvas) {
    const ctx2 = canvas.getContext('2d');
    const W = canvas.width = canvas.clientWidth * devicePixelRatio;
    const H = canvas.height = canvas.clientHeight * devicePixelRatio;
    ctx2.clearRect(0,0,W,H);
    ctx2.fillStyle = '#0b0f29'; ctx2.fillRect(0,0,W,H);
    ctx2.lineWidth = 2 * devicePixelRatio; ctx2.strokeStyle = '#8be9fd';
    ctx2.beginPath();

    const ch = buffer.numberOfChannels > 1 ? mixToMono(buffer) : buffer.getChannelData(0);
    const step = Math.max(1, Math.ceil(ch.length / W));
    const amp = H / 2 * 0.9; const base = (H - 2*amp)/2;
    for (let x = 0; x < W; x++) {
      const start = x * step;
      let min = 1, max = -1;
      for (let i = 0; i < step && start + i < ch.length; i++) {
        const v = ch[start + i];
        if (v < min) min = v; if (v > max) max = v;
      }
      ctx2.moveTo(x, (1 - min) * amp + base);
      ctx2.lineTo(x, (1 - max) * amp + base);
    }
    ctx2.stroke();
  }

  function mixToMono(buffer) {
    const len = buffer.length; const tmp = new Float32Array(len);
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
      const data = buffer.getChannelData(ch);
      for (let i = 0; i < len; i++) tmp[i] += data[i];
    }
    for (let i = 0; i < len; i++) tmp[i] /= buffer.numberOfChannels;
    return tmp;
  }

  async function bufferToBlob(buffer, sampleRate) {
    const chData = Array.from({length: buffer.numberOfChannels}, (_, c) => buffer.getChannelData(c));
    const interleaved = interleaveIfNeeded(chData);
    const wav = pcm16ToWav(interleaved, sampleRate, buffer.numberOfChannels);
    return new Blob([wav], { type: 'audio/wav' });
  }

  function interleaveIfNeeded(chArrays) {
    if (chArrays.length === 1) return chArrays[0];
    const length = chArrays[0].length;
    const out = new Float32Array(length * chArrays.length);
    for (let i = 0; i < length; i++)
      for (let ch = 0; ch < chArrays.length; ch++)
        out[i * chArrays.length + ch] = chArrays[ch][i];
    return out;
  }

  function pcm16ToWav(samples, sampleRate, numChannels=1) {
    const bytesPerSample = 2, blockAlign = numChannels * bytesPerSample;
    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    const view = new DataView(buffer);
    let o = 0;
    const ws = s => { for (let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); };
    const w32 = v => { view.setUint32(o, v, true); o+=4; };
    const w16 = v => { view.setUint16(o, v, true); o+=2; };
    ws('RIFF'); w32(36 + samples.length * bytesPerSample); ws('WAVE');
    ws('fmt '); w32(16); w16(1); w16(numChannels); w32(sampleRate);
    w32(sampleRate * blockAlign); w16(blockAlign); w16(16);
    ws('data'); w32(samples.length * bytesPerSample);
    for (let i = 0; i < samples.length; i++) {
      let s = Math.max(-1, Math.min(1, samples[i]));
      view.setInt16(o, s < 0 ? s * 0x8000 : s * 0x7fff, true); o += 2;
    }
    return view;
  }

  // --- Similitud ---
  function monoFromBuffer(buffer){
    return buffer.numberOfChannels > 1 ? mixToMono(buffer) : buffer.getChannelData(0);
  }
  function resampleMonoTo(array, newLen) {
    const out = new Float32Array(newLen);
    const factor = (array.length - 1) / (newLen - 1);
    for (let i = 0; i < newLen; i++) {
      const pos = i * factor, idx = Math.floor(pos), frac = pos - idx;
      const a = array[idx] || 0, b = array[idx+1] || 0;
      out[i] = a + (b - a) * frac;
    }
    return out;
  }
  function normalizeZeroMeanUnitVar(arr) {
    let mean = 0; for (let i=0;i<arr.length;i++) mean += arr[i]; mean/=arr.length;
    let varsum = 0; for (let i=0;i<arr.length;i++){ const v = arr[i]-mean; varsum += v*v; }
    const std = Math.sqrt(varsum/arr.length) || 1;
    const out = new Float32Array(arr.length);
    for (let i=0;i<arr.length;i++) out[i] = (arr[i]-mean)/std;
    return out;
  }
  function cosineSimilarity(a,b){
    let dot=0, na=0, nb=0;
    for (let i=0;i<a.length;i++){ const x=a[i], y=b[i]; dot+=x*y; na+=x*x; nb+=y*y; }
    if (!na || !nb) return 0; return dot / (Math.sqrt(na) * Math.sqrt(nb));
  }
  function scoreSimilarity(orig, attempt){
    const TARGET = 16000;
    const a = normalizeZeroMeanUnitVar(resampleMonoTo(monoFromBuffer(orig), TARGET));
    const b = normalizeZeroMeanUnitVar(resampleMonoTo(monoFromBuffer(attempt), TARGET));
    const cos = Math.max(0, cosineSimilarity(a,b));
    return Math.round(cos*100);
  }

  // --- Eventos UI ---
  permState.textContent = 'pendiente';
  btnPerms.addEventListener('click', requestMic);

  // REC 1
  rec1.addEventListener('click', async () => {
    if (!mediaStream) await requestMic();
    const { mr } = armRecorder(1);
    ensureCtx().resume?.();
    mediaRecorder1 = mr; chunks1 = []; mr.start();
    rec1.disabled = true; stop1.disabled = false;
    rec1.classList.add('recording');
    rec1.textContent = '‚è∫Ô∏è Grabando‚Ä¶';
  });
  stop1.addEventListener('click', () => {
    if (mediaRecorder1 && mediaRecorder1.state !== 'inactive'){
      mediaRecorder1.stop(); stop1.disabled = true; rec1.disabled = false;
      rec1.classList.remove('recording');
      rec1.textContent = '‚è∫Ô∏è Grabar';
    }
  });

  // REC 2
  rec2.addEventListener('click', async () => {
    if (!mediaStream) await requestMic();
    const { mr } = armRecorder(2);
    ensureCtx().resume?.();
    mediaRecorder2 = mr; chunks2 = []; mr.start();
    rec2.disabled = true; stop2.disabled = false;
    rec2.classList.add('recording');
    rec2.textContent = '‚è∫Ô∏è Grabando‚Ä¶';
  });
  stop2.addEventListener('click', () => {
    if (mediaRecorder2 && mediaRecorder2.state !== 'inactive'){
      mediaRecorder2.stop(); stop2.disabled = true; rec2.disabled = false;
      rec2.classList.remove('recording');
      rec2.textContent = '‚è∫Ô∏è Grabar intento';
    }
  });

  // Reproducir con los BOTONES (y mostrar barra)
  playRev1.addEventListener('click', async () => {
    if (!audio1rev.src) return;
    audio1rev.classList.remove('hidden');
    try { await ensureCtx().resume?.(); await audio1rev.play(); } catch {}
  });
  playFix2.addEventListener('click', async () => {
    if (!audio2fix.src) return;
    audio2fix.classList.remove('hidden');
    try { await ensureCtx().resume?.(); await audio2fix.play(); } catch {}
  });

  // Descargas
  dl1.addEventListener('click', () => {
    if (!blob1) return; const a = document.createElement('a');
    a.href = URL.createObjectURL(blob1); a.download = 'frase-original.webm'; a.click();
  });
  dl2.addEventListener('click', () => {
    if (!blob2) return; const a = document.createElement('a');
    a.href = URL.createObjectURL(blob2); a.download = 'intento-backwards.webm'; a.click();
  });

  // Comparar
  btnCompare.addEventListener('click', () => {
    if (!(buf1 && buf2Fix)) return;
    const s = scoreSimilarity(buf1, buf2Fix);
    scoreEl.textContent = s + ' / 100';
    scoreEl.classList.remove('good','mid','bad');
    scoreEl.classList.add(s >= 70 ? 'good' : s >= 40 ? 'mid' : 'bad');
  });

  // Reset
  btnReset.addEventListener('click', () => {
    [audio1,audio1rev,audio2,audio2fix].forEach(a => { a.pause?.(); a.src=''; a.classList.add('hidden'); });
    [wave1,wave1rev,wave2,wave2fix].forEach(c => { const g=c.getContext('2d'); g.clearRect(0,0,c.width,c.height); });
    blob1=blob2=null; buf1=buf1Rev=buf2=buf2Fix=null;
    playRev1.disabled = true; playFix2.disabled = true; btnCompare.disabled = true;
    rec2.disabled = true; dl1.disabled = true; dl2.disabled = true;
    rec1.classList.remove('recording'); rec1.textContent='‚è∫Ô∏è Grabar';
    rec2.classList.remove('recording'); rec2.textContent='‚è∫Ô∏è Grabar intento';
    scoreEl.textContent = '‚Äî'; scoreEl.classList.remove('good','mid','bad');
  });
})();
</script>
</body>
</html>
