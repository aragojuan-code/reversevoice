<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Laboratorio de Ecos Invertidos</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#171a2b; --ink:#e8ecff; --muted:#9aa7ffcc;
      --accent:#8be9fd; --good:#4ade80; --warn:#fbbf24; --bad:#fb7185;
      --border:#1f2342; --tile:#0f1330;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
      background:linear-gradient(180deg,#0b0e1a,#121629);color:var(--ink);
    }
    header{padding:18px 14px;text-align:center}
    h1{margin:0;font-size:clamp(22px,3.5vw,34px);letter-spacing:.2px}
    .subtitle{margin:6px 0 0;font-size:13px;color:var(--muted)}
    main{max-width:920px;margin:0 auto;padding:12px 14px 28px;display:grid;gap:14px}
    .card{
      background:var(--panel);border:1px solid var(--border);border-radius:16px;
      padding:12px 12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.25)
    }
    .section-title{margin:0 0 10px;font-size:16px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row > *{flex:1 1 auto}
    label{font-size:13px;color:var(--muted)}
    input[type=text]{
      width:100%;padding:11px 12px;border-radius:12px;background:var(--tile);
      border:1px solid #212757;color:var(--ink);outline:none;min-width:0
    }
    input[type=text]::placeholder{color:#9aa7ff99}
    button{
      appearance:none;border:0;border-radius:12px;padding:11px 12px;background:#23284d;
      color:var(--ink);font-weight:600;cursor:pointer;transition:.15s transform,.15s filter,.2s background;white-space:nowrap
    }
    button:hover{filter:brightness(1.08)}
    button:active{transform:translateY(1px)}
    .primary{background:linear-gradient(135deg,#3b82f6,#8b5cf6)}
    .good{background:linear-gradient(135deg,#22c55e,#16a34a)}
    .warn{background:linear-gradient(135deg,#f59e0b,#eab308)}
    .bad{background:linear-gradient(135deg,#ef4444,#f43f5e)}
    .ghost{background:transparent;border:1px solid #2a2f5d}
    .pill{
      display:inline-flex;align-items:center;gap:8px;padding:7px 10px;border-radius:999px;
      background:var(--tile);border:1px solid #26306b;font-size:12px;color:var(--muted)
    }
    .grid{display:grid;gap:10px}
    .cols-2{grid-template-columns:1fr 1fr}
    @media (max-width:800px){ .cols-2{grid-template-columns:1fr} }
    .hidden{display:none !important}
    canvas{
      width:100%;height:64px;
      background:#0b0f29;border-radius:10px;border:1px solid #212757
    }
    @media (min-width:900px){ canvas{height:72px} }

    /* Estado de GRABACI√ìN visible */
    .recording{
      background:linear-gradient(135deg,#b91c1c,#ef4444) !important;
      box-shadow:0 0 0 0 rgba(239,68,68,.75);
      animation:pulse 1.2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%{box-shadow:0 0 0 0 rgba(239,68,68,.55)}
      70%{box-shadow:0 0 0 12px rgba(239,68,68,0)}
      100%{box-shadow:0 0 0 0 rgba(239,68,68,0)}
    }
  </style>
</head>
<body>
  <header>
    <h1>Laboratorio de Ecos Invertidos</h1>
    <p class="subtitle">Graba ‚Üí escucha al rev√©s ‚Üí im√≠talo ‚Üí lo volvemos al derecho</p>
  </header>

  <main>
    <section class="card">
      <div class="grid">
        <div class="row">
          <label for="phrase">Frase gu√≠a (opcional):</label>
          <input id="phrase" type="text" placeholder="Escribe aqu√≠ la frase que vas a decir (opcional)">
        </div>
        <div class="row" style="align-items:center">
          <span class="pill">Micr√≥fono: <b id="permState">pendiente</b></span>
          <button id="btnPerms" class="ghost" style="flex:0 0 auto">Conceder permiso</button>
          <span class="subtitle" style="flex:1 1 100%">Tip: usa <b>https</b> o <b>localhost</b> para que funcione el micro.</span>
        </div>
      </div>
    </section>

    <section class="card">
      <h3 class="section-title">1) Graba tu frase</h3>
      <div class="grid cols-2">
        <div>
          <div class="row">
            <button id="rec1" class="primary">‚è∫Ô∏è Grabar</button>
            <button id="stop1" class="bad" disabled>‚èπÔ∏è Detener</button>
            <button id="dl1" class="ghost" disabled>‚¨áÔ∏è Descargar</button>
          </div>
          <audio id="audio1" controls class="hidden"></audio>
          <canvas id="wave1"></canvas>
        </div>
        <div>
          <div class="row">
            <button id="playRev1" class="warn" disabled>üîÅ Escuchar al rev√©s</button>
          </div>
          <audio id="audio1rev" controls class="hidden"></audio>
          <canvas id="wave1rev"></canvas>
        </div>
      </div>
    </section>

    <section class="card">
      <h3 class="section-title">2) Im√≠talo al rev√©s</h3>
      <div class="grid cols-2">
        <div>
          <div class="row">
            <button id="rec2" class="primary" disabled>‚è∫Ô∏è Grabar intento</button>
            <button id="stop2" class="bad" disabled>‚èπÔ∏è Detener</button>
            <button id="dl2" class="ghost" disabled>‚¨áÔ∏è Descargar</button>
          </div>
          <audio id="audio2" controls class="hidden"></audio>
          <canvas id="wave2"></canvas>
        </div>
        <div>
          <div class="row">
            <button id="playFix2" class="good" disabled>‚Ü©Ô∏è Volver al derecho</button>
          </div>
          <audio id="audio2fix" controls class="hidden"></audio>
          <canvas id="wave2fix"></canvas>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  // --- Estado ---
  let mediaStream = null;
  let mediaRecorder1 = null, mediaRecorder2 = null;
  let chunks1 = [], chunks2 = [];
  let blob1 = null, blob2 = null;
  let ctx = null;

  // Buffers decodificados
  let buf1 = null, buf1Rev = null, buf2 = null, buf2Fix = null;

  // --- Elementos ---
  const $ = (id) => document.getElementById(id);
  const permState = $('permState'), btnPerms = $('btnPerms');

  const rec1 = $('rec1'), stop1 = $('stop1'), audio1 = $('audio1');
  const playRev1 = $('playRev1'), audio1rev = $('audio1rev');
  const wave1 = $('wave1'), wave1rev = $('wave1rev'), dl1 = $('dl1');

  const rec2 = $('rec2'), stop2 = $('stop2'), audio2 = $('audio2');
  const playFix2 = $('playFix2'), audio2fix = $('audio2fix');
  const wave2 = $('wave2'), wave2fix = $('wave2fix'), dl2 = $('dl2');

  // --- Helpers audio ---
  const ensureCtx = () => (ctx ||= new (window.AudioContext || window.webkitAudioContext)());

  async function requestMic() {
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      permState.textContent = 'concedido';
      btnPerms.disabled = true;
    } catch (e) {
      permState.textContent = 'denegado';
      alert('No se pudo acceder al micr√≥fono. Abre el archivo en https/localhost y concede permisos.');
      throw e;
    }
  }

  function armRecorder(which) {
    const mr = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });
    const chunks = [];
    mr.ondataavailable = (e) => { if (e.data.size) chunks.push(e.data); };
    mr.onstop = async () => {
      const blob = new Blob(chunks, { type: 'audio/webm' });
      if (which === 1) { blob1 = blob; await handleRecordedBlob(blob1, 1); }
      else { blob2 = blob; await handleRecordedBlob(blob2, 2); }
    };
    return { mr, chunks };
  }

  async function handleRecordedBlob(blob, which) {
    const arrayBuf = await blob.arrayBuffer();
    const audioCtx = ensureCtx();
    const decoded = await audioCtx.decodeAudioData(arrayBuf.slice(0));

    if (which === 1) {
      buf1 = decoded;
      audio1.src = URL.createObjectURL(blob);
      audio1.classList.remove('hidden');
      drawWaveform(decoded, wave1);

      buf1Rev = reverseBuffer(decoded);
      const revBlob = await bufferToBlob(buf1Rev, audioCtx.sampleRate);
      audio1rev.src = URL.createObjectURL(revBlob);
      audio1rev.classList.remove('hidden');
      drawWaveform(buf1Rev, wave1rev);

      playRev1.disabled = false; dl1.disabled = false; rec2.disabled = false;
    } else {
      buf2 = decoded;
      audio2.src = URL.createObjectURL(blob);
      audio2.classList.remove('hidden');
      drawWaveform(decoded, wave2);

      buf2Fix = reverseBuffer(decoded);
      const fixBlob = await bufferToBlob(buf2Fix, ensureCtx().sampleRate);
      audio2fix.src = URL.createObjectURL(fixBlob);
      audio2fix.classList.remove('hidden');
      drawWaveform(buf2Fix, wave2fix);

      playFix2.disabled = false; dl2.disabled = false;
    }
  }

  function reverseBuffer(buffer) {
    const audioCtx = ensureCtx();
    const out = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
      const src = buffer.getChannelData(ch);
      const dst = out.getChannelData(ch);
      for (let i = 0, j = src.length - 1; i < src.length; i++, j--) dst[i] = src[j];
    }
    return out;
  }

  function drawWaveform(buffer, canvas) {
    const ctx2 = canvas.getContext('2d');
    const W = canvas.width = canvas.clientWidth * devicePixelRatio;
    const H = canvas.height = canvas.clientHeight * devicePixelRatio;
    ctx2.clearRect(0,0,W,H);
    ctx2.fillStyle = '#0b0f29'; ctx2.fillRect(0,0,W,H);
    ctx2.lineWidth = 2 * devicePixelRatio; ctx2.strokeStyle = '#8be9fd';
    ctx2.beginPath();

    const ch = buffer.numberOfChannels > 1 ? mixToMono(buffer) : buffer.getChannelData(0);
    const step = Math.max(1, Math.ceil(ch.length / W));
    const amp = H / 2 * 0.9; const base = (H - 2*amp)/2;
    for (let x = 0; x < W; x++) {
      const start = x * step;
      let min = 1, max = -1;
      for (let i = 0; i < step && start + i < ch.length; i++) {
        const v = ch[start + i];
        if (v < min) min = v; if (v > max) max = v;
      }
      ctx2.moveTo(x, (1 - min) * amp + base);
      ctx2.lineTo(x, (1 - max) * amp + base);
    }
    ctx2.stroke();
  }

  function mixToMono(buffer) {
    const len = buffer.length; const tmp = new Float32Array(len);
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
      const data = buffer.getChannelData(ch);
      for (let i = 0; i < len; i++) tmp[i] += data[i];
    }
    for (let i = 0; i < len; i++) tmp[i] /= buffer.numberOfChannels;
    return tmp;
  }

  async function bufferToBlob(buffer, sampleRate) {
    const chData = Array.from({length: buffer.numberOfChannels}, (_, c) => buffer.getChannelData(c));
    const interleaved = interleaveIfNeeded(chData);
    const wav = pcm16ToWav(interleaved, sampleRate, buffer.numberOfChannels);
    return new Blob([wav], { type: 'audio/wav' });
  }

  function interleaveIfNeeded(chArrays) {
    if (chArrays.length === 1) return chArrays[0];
    const length = chArrays[0].length;
    const out = new Float32Array(length * chArrays.length);
    for (let i = 0; i < length; i++)
      for (let ch = 0; ch < chArrays.length; ch++)
        out[i * chArrays.length + ch] = chArrays[ch][i];
    return out;
  }

  function pcm16ToWav(samples, sampleRate, numChannels=1) {
    const bytesPerSample = 2, blockAlign = numChannels * bytesPerSample;
    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    const view = new DataView(buffer);
    let o = 0;
    const ws = s => { for (let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); };
    const w32 = v => { view.setUint32(o, v, true); o+=4; };
    const w16 = v => { view.setUint16(o, v, true); o+=2; };
    ws('RIFF'); w32(36 + samples.length * bytesPerSample); ws('WAVE');
    ws('fmt '); w32(16); w16(1); w16(numChannels); w32(sampleRate);
    w32(sampleRate * blockAlign); w16(blockAlign); w16(16);
    ws('data'); w32(samples.length * bytesPerSample);
    for (let i = 0; i < samples.length; i++) {
      let s = Math.max(-1, Math.min(1, samples[i]));
      view.setInt16(o, s < 0 ? s * 0x8000 : s * 0x7fff, true); o += 2;
    }
    return view;
  }

  // --- Permisos ---
  permState.textContent = 'pendiente';
  btnPerms.addEventListener('click', requestMic);

  // REC 1
  rec1.addEventListener('click', async () => {
    if (!mediaStream) await requestMic();
    const { mr } = armRecorder(1);
    ensureCtx().resume?.();
    mediaRecorder1 = mr; chunks1 = []; mr.start();
    rec1.disabled = true; stop1.disabled = false;
    rec1.classList.add('recording'); rec1.textContent = '‚è∫Ô∏è Grabando‚Ä¶';
  });
  stop1.addEventListener('click', () => {
    if (mediaRecorder1 && mediaRecorder1.state !== 'inactive'){
      mediaRecorder1.stop(); stop1.disabled = true; rec1.disabled = false;
      rec1.classList.remove('recording'); rec1.textContent = '‚è∫Ô∏è Grabar';
    }
  });

  // REC 2
  rec2.addEventListener('click', async () => {
    if (!mediaStream) await requestMic();
    const { mr } = armRecorder(2);
    ensureCtx().resume?.();
    mediaRecorder2 = mr; chunks2 = []; mr.start();
    rec2.disabled = true; stop2.disabled = false;
    rec2.classList.add('recording'); rec2.textContent = '‚è∫Ô∏è Grabando‚Ä¶';
  });
  stop2.addEventListener('click', () => {
    if (mediaRecorder2 && mediaRecorder2.state !== 'inactive'){
      mediaRecorder2.stop(); stop2.disabled = true; rec2.disabled = false;
      rec2.classList.remove('recording'); rec2.textContent = '‚è∫Ô∏è Grabar intento';
    }
  });

  // Reproducir (y mostrar barra)
  playRev1.addEventListener('click', async () => {
    if (!audio1rev.src) return;
    audio1rev.classList.remove('hidden');
    try { await ensureCtx().resume?.(); await audio1rev.play(); } catch {}
  });
  playFix2.addEventListener('click', async () => {
    if (!audio2fix.src) return;
    audio2fix.classList.remove('hidden');
    try { await ensureCtx().resume?.(); await audio2fix.play(); } catch {}
  });

  // Descargas
  dl1.addEventListener('click', () => {
    if (!blob1) return; const a = document.createElement('a');
    a.href = URL.createObjectURL(blob1); a.download = 'frase-original.webm'; a.click();
  });
  dl2.addEventListener('click', () => {
    if (!blob2) return; const a = document.createElement('a');
    a.href = URL.createObjectURL(blob2); a.download = 'intento-backwards.webm'; a.click();
  });
})();
</script>
</body>
</html>
